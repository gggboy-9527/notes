# Node.js、操作系统、进程、线程、子进程完整理解笔记（通俗但准确版）

## 一、操作系统运行程序的基本方式

所有操作系统（Windows / Linux / macOS）运行程序时，都遵循同一套逻辑。

### 1. 程序运行后会变成“进程”
- 你双击一个程序、启动 Node.js、运行 Python，本质上都是“创建一个进程”。
- **进程是操作系统分配资源的最小单位**：
  - 独立内存
  - 独立权限
  - 独立文件句柄
  - 独立运行状态
  - 不同进程之间必须通过 **进程间通信（IPC）** 交换数据
  - 创建成本高

一句话总结：
> Node.js 跑起来就是一个进程。

### 2. 进程内部包含多个线程
- **线程才是 CPU 真正调度的对象**。
- CPU 工作的本质是：线程在不同 CPU 核之间切换并执行。
- 线程创建成本远低于进程。

### 3. 线程能否跨 CPU 核？
可以。  
**操作系统会根据负载把不同线程分给不同 CPU 核。**

---

## 二、进程 vs 线程的本质区别

| 对比点   | 进程           | 线程                         |
| -------- | -------------- | ---------------------------- |
| 内存     | 独立内存空间   | 共享同一进程内存             |
| 崩溃影响 | 进程间互不影响 | 一个线程崩掉可能影响整个进程 |
| 开销     | 大             | 小                           |
| 通信     | 需要 IPC       | 可直接共享内存               |

一句话总结：
> 进程是装线程的容器，线程才是在 CPU 上真正跑的东西。

---

## 三、父进程与子进程为什么存在？

这是操作系统本身的设计，而不是 Node.js 发明的。

原因：
- 记录“谁创建了谁”
- 父进程可以管理子进程（回收资源）
- 子进程继承父进程环境
- 可以构建进程树，让系统更好地管理资源

Linux 里所有进程最终都能追溯到 PID 1（init/systemd）。

你可以看到进程树：

```bash
pstree -p
```

## 四、进程间通信方式（IPC）

### 1. 管道（Pipe）

Node 子进程创建时，就自动拥有 IPC 管道：

```
const child = fork('./worker.js');
child.send({ task: 1 });
child.on('message', data => console.log(data));
```

适合父 ⟷ 子之间通信。

------

### 2. TCP / HTTP / Socket

让多个 Node 进程通过网络通信，这是最常用方式。

例如：

- PM2 cluster 模式内部使用 socket
- 微服务架构中各个 Node 服务用 HTTP/RPC 通信

------

### 3. Redis/MQ 等消息队列（更常用）

用于多进程之间协调任务：

- Redis pub/sub
- Bull 队列
- RabbitMQ
- Kafka

适合多实例之间共享任务。

------

### 4. 共享内存（高级用法）

Node.js 支持 SharedArrayBuffer，但非常少用，因为：

- 难度大
- 极易出错
- 不适合 Node 的事件模型

## 五、Node.js 的执行模式（关键知识）

**Node.js=一个 OS 级别的进程（Process）**

一个 Node.js 进程默认包含多个线程，比如：

- JavaScript 主线程（运行 JS）

- libuv 线程池（默认 4 个）

- V8 的垃圾回收线程

- 其他辅助线程（一些内部模块）

  即：
   **Node 进程 = 多线程，但 JS 只能运行在其中的“主线程”上。**



------

## 六、Node.js 多进程模型

Node.js 提供创建多个 Node 进程的能力，用于充分利用多核 CPU：

- `child_process.spawn`
- `child_process.exec`
- `child_process.fork`
- `cluster` 模块
- PM2 的 cluster 模式

### Node.js 的“子进程”是什么？

它不是线程，而是**完整的 Node.js 进程**：

- 独立 V8 引擎
- 独立事件循环
- 独立内存
- 可运行在不同 CPU 核上

------

## 七、Node.js 子进程之间的通讯方式

Node.js 内置 IPC 信道，只要用 `fork`，就可以直接通信：

```javascript
child.send({ task: "hello" });
child.on("message", ...)
```

其它方式包括：

- TCP/HTTP
- Redis pub/sub
- MQ
- 数据库作为中介

------

## 八、为什么叫“子进程”？

因为它是操作系统创建的“新进程”，系统规定必须记为父进程的子进程。
 这不是 Node.js 的命名规则，而是 OS 的机制。

总结：

- Node.js 创建的并非“线程”，而是 OS 的“进程”
- 父子关系来自 OS，不是 Node.js 发明的

------

## 九、Node.js 多核利用方式

单个 Node.js 进程通常跑在一个 CPU 核上。

但你可以：

1. 启动多个 Node.js 进程让它们分布在多个 CPU 核
2. 利用 libuv 线程池处理 I/O 和 CPU 密集任务
3. 通过 IPC/Redis/MQ 等方式通信

大型 Node 服务一般都是：

> “多进程 + 线程池”的并行结构。

------

## 十、为什么多进程有时反而更慢？

因为：

- 进程开销巨大
- 进程间通信慢，需要序列化数据
- 需要更多内存

因此：

> 多进程适用于真正 CPU 密集型任务，而不是所有场景。

你之前“子进程执行任务 + 队列通知”的做法，属于正确使用场景。

------

# 最终总体总结

1. Node.js 程序跑起来就是一个进程。
2. Node.js 单线程执行 JS，但底层有多线程的 libuv 线程池。
3. 进程是资源单位，线程是 CPU 调度单位。
4. 多核 CPU 可运行多个进程或多个线程。
5. 子进程是 OS 概念，不是 Node.js 发明的。
6. Node 子进程是完整 Node 进程而非线程。
7. 子进程与父进程可以通过 IPC 互相通信。
8. 多进程适合 CPU 密集任务，不适合轻量任务。
9. 进程隔离，线程共享内存。