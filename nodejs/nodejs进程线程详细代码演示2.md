# 第二条：父进程创建“子进程”（child_process.fork），并演示父子进程之间的通信

这一条将解决你之前提出的几个关键疑问：

- 子进程到底是不是新的 Node 进程？
- 为什么叫子进程？父进程和子进程的关系是什么？
- 父子之间怎样通信？
- 是否能互相传数据？
- 任务管理器里能看到两个 Node 进程吗？

下面会通过一个完整、可运行的 Node.js 例子来演示。

------

# 一、准备两个 JS 文件

在 VSCode 同一个文件夹中新建两个文件。

------

## 1. child.js（子进程文件）

```
// child.js

console.log('子进程已启动，PID:', process.pid);

// 接收来自父进程的消息
process.on('message', (msg) => {
  console.log(`子进程收到消息:`, msg);

  // 模拟一个计算任务
  const result = msg.number * 2;

  // 将结果发送回父进程
  process.send({ result });
});

// 当子进程即将退出时
process.on('exit', () => {
  console.log('子进程退出，PID:', process.pid);
});
```

------

## 2. parent.js（父进程文件）

```
// parent.js

const { fork } = require('child_process');

// 启动一个子进程
const child = fork('./child.js');

console.log('父进程已启动，PID:', process.pid);
console.log('子进程 PID:', child.pid);

// 向子进程发送消息
child.send({ number: 21 });

// 接受子进程的返回结果
child.on('message', (msg) => {
  console.log('父进程收到子进程结果:', msg);

  // 完成通信后结束子进程
  child.kill();
});
```

------

# 二、运行演示

在终端运行：

```
node parent.js
```

你将看到类似输出：

```
父进程已启动，PID: 11200
子进程 PID: 14392
子进程已启动，PID: 14392
子进程收到消息: { number: 21 }
父进程收到子进程结果: { result: 42 }
子进程退出，PID: 14392
```

------

# 三、任务管理器中你会看到什么？

当你运行 `node parent.js` 时：

- **任务管理器里会出现两个 Node 进程：**
  - 一个是父进程（运行 parent.js）
  - 一个是子进程（运行 child.js）

这清楚证明：

**child_process.fork 创建的是一个全新、独立的 Node.js 进程，而不是线程。**

------

# 四、你刚刚验证了几个核心概念

## 1. 子进程是真实的 OS 进程

不是“虚拟概念”，实实在在的多一个 node.exe。

## 2. 为什么叫“子进程”？

因为在操作系统内部，它的 **PPID（Parent Process ID）等于父进程 PID**。

父子关系是 OS 级别原生支持的。

## 3. 父子之间可以通信

这是 Node 提供的 IPC 通道：

- `child.send(...)`
- `process.on("message", ...)`

你刚刚测试过了。

## 4. 父进程可以管理子进程（启动、杀死、重启、监听）

例如：

- `child.kill()`
- `child.on('exit')`

------

# 五、你解决了你之前问的这两个困惑

### （1）“子进程不就是新创建的进程吗？为什么叫子进程？”

因为 OS 中所有进程都有父亲，这是系统模型，并非 Node.js 特有。

### （2）“多个 Node 进程之间能通讯吗？”

是的，但父子进程可以直接通信（Node 内置 IPC 机制）。
 两个完全无关的 Node 进程也能通信（TCP/WebSocket/Redis 等）。

------



# 六、为什么不调用 child.kill() 时父子进程都保持存活？

因为：

**父进程与子进程是两个完全独立的操作系统进程。**

它们的生命周期互不影响，除非你显式地结束某一方。

### 举例：

你运行：

```
node parent.js
```

产生两个进程：

- 父进程（运行 parent.js）
- 子进程（运行 child.js）

**只要父进程没有退出，子进程也没有退出，它们就都会一直存在。**

尤其是：

### 子进程是一个独立 Node 程序，它内部有：

- 事件循环
- 非结束状态
- 等待消息的监听器（如 process.on('message', ...)）
- 也可能有其他事件或异步任务

只要其中任意条件没有解除，该进程就不会自动退出。

------

# 七、为什么父进程不会自动结束？

在 parent.js 中：

```
child.on('message', (msg) => {
  console.log('父进程收到子进程结果:', msg);

  // 完成通信后结束子进程
  // child.kill();
});
```

如果你注释掉 child.kill()，父进程依然不会退出，因为：

**只要有一个子进程仍然存活，Node 主程序会保持运行**
 除非你明确退出，例如：

- 父进程调用 `process.exit()`
- 某些事件循环全部停止

------

# 八、为什么子进程也不会自动退出？

因为你写了：

```
process.on('message', ...)
```

只要这一监听器存在，Node 会认为你还可能接收新的消息，因此：

**事件循环保持活跃 → 进程不退出**

子进程必须：

- 没有任何活跃的事件监听器
- 和没有未完成的异步任务

进程才会自动退出。

你的 child.js 还有 console.log，而且保持监听 message，意味着它处于“等待消息”的状态，自然不会退出。

------

# 九、父子进程生命周期关系总结（重要）

## 1. 父进程退出后，会不会带走子进程？

在 Node.js 中：

- **Windows：父进程退出不会杀死子进程**
- **Linux/macOS：父进程退出后，子进程会变成孤儿进程，被 init/systemd 接管，继续运行**

也就是说：

**子进程不会因为父进程退出而自动退出。**

------

## 2. 子进程退出后，父进程会怎样？

父进程会收到：

```
child.on('exit', ...)
```

但父进程本身不会退出。

------

# 十、也就是说，child.kill() 的作用并不是“必须”，而是你为了控制生命周期

你加 kill 是：

- 任务完成就干净退出
- 防止僵尸进程
- 避免浪费资源

如果不加 kill，不会影响代码逻辑，但进程就会一直存在。

------

# 十一、真实项目中通常如何处理？

### 1. 子进程模式（child_process）

适用于 CPU 密集任务。
 通常流程是：

- 父进程启动子进程
- 子进程执行计算
- 子进程返回结果
- **子进程自动“自杀”（退出）**

例如在 child.js 中：

```
process.send({ result });

// 自动退出子进程
process.exit(0);
```

这样就不需要父进程 kill。

------

### 2. 批处理系统（队列）

如果子进程需要持续处理任务（如你的 bull 队列）：
 则子进程会一直运行，直到你手动停止。这个时候你不 kill 是正常的。

------

### 3. Cluster 模式（多个 Node 进程）

PM2 会自动管理多个 Node 进程：

- 崩了自动重启
- 可平滑重启
- 可负载均衡

这种情况下也不需要你 kill。