**什么是 Docker？**

Docker 是一个用于开发(**关于开发的这个说法，可以去看使用容器开发这个笔记；**)、交付和运行应用程序的开放平台。Docker 使您能够将应用程序**与基础设施分离**，从而可以快速交付软件。借助 Docker，您可以像管理应用程序一样管理基础设施。通过利用 Docker 的代码交付、测试和部署方法，您可以显著缩短编写代码与在生产环境中运行代码之间的延迟。

**解析：与基础设施分离”中的“基础设施”指什么？**

这里的**基础设施**指的是应用程序运行所依赖的**底层物理和软件环境**，具体包括：

- **物理硬件：** 服务器品牌、CPU型号、内存大小、磁盘类型。
- **操作系统：** 是 CentOS 7.9 还是 Ubuntu 22.04？内核版本是什么？
- **运行时环境：** 是 Java 11 还是 Java 17？Node.js 的版本是多少？
- **系统依赖：** 需要安装哪些特定的系统库（如 `libssl`）？
- **配置和网络：** IP地址、防火墙规则、存储挂载点。

**“分离”的含义：**
以前，应用和基础设施紧密耦合。部署应用时需要在一台特定配置的服务器上反复安装和配置环境。现在，Docker 将 **“应用及其所有依赖（代码、运行时、系统工具、系统库）”** 一起打包进容器。这个容器可以运行在**任何安装了 Docker 引擎的机器上**，而不关心底层基础设施的具体细节。基础设施只需提供标准的 Docker 运行环境即可。

------

**Docker 平台**

Docker 提供了在一种称为容器的松散隔离环境中打包和运行应用程序的能力。隔离性和安全性使您可以在给定主机上同时运行多个容器。容器是轻量级的，包含运行应用程序所需的一切，因此您无需依赖主机上已安装的内容。您可以在工作中共享容器，并确保所有共享者都能获得以相同方式运行的相同容器。

Docker 提供了工具和平台来管理容器的生命周期：

- 使用容器开发应用程序及其支持组件。
- 容器成为分发和测试应用程序的单元。
- 当您准备好时，将应用程序作为容器或编排服务部署到生产环境中。无论您的生产环境是本地数据中心、云提供商还是两者的混合，此过程的工作方式都相同。

**解析：“使用容器开发应用程序及其支持组件”详解**

**支持组件**指的是应用程序正常运行所需的“配角”服务，通常也称为**辅助服务**或**依赖服务**。例如：

- 一个Web应用（主应用）需要 MySQL 数据库（支持组件）来存数据。
- 一个微服务需要 Redis（支持组件）来做缓存。
- 一个应用需要 Elasticsearch（支持组件）来提供搜索功能。

**传统做法：** 开发者在本地安装 MySQL、Redis，配置非常麻烦，且版本容易冲突。
**Docker 做法：** 开发者无需在本地主机安装这些软件。他们只需要运行对应的**官方容器镜像**：

bash

```
docker run -d --name my-mysql mysql:8.0
docker run -d --name my-redis redis:alpine
```



然后，他们的主应用容器就可以通过网络连接到这些“支持组件”容器进行开发测试。所有组件都以容器形式存在，干净、独立、易管理。

------

**Docker 可以用于什么？**

**快速、一致的应用程序交付**
Docker 通过允许开发人员在提供应用程序和服务的本地容器所构成的标准化环境中工作，简化了开发生命周期。【这句话的意思是：Docker 创建了一种标准化的环境，这个环境就是运行在本地的容器。开发人员就在这些容器里工作和测试他们的应用程序与服务。Docker 通过这种方式赋能开发人员。】容器非常适合持续集成和持续交付（CI/CD）工作流程。

考虑以下示例场景：

- 您的开发人员在本地编写代码，并使用 Docker 容器与同事共享他们的工作。
- 他们使用 Docker 将应用程序推送到测试环境，并运行自动化和手动测试。
- 当开发人员发现错误时，他们可以在开发环境中修复错误，然后重新部署到测试环境进行测试和验证。
- 测试完成后，将修复程序交付给客户就像将更新的镜像推送到生产环境一样简单。

**响应式部署和扩展**
Docker 基于容器的平台支持高度可移植的工作负载。Docker 容器可以在开发人员的本地笔记本电脑、数据中心中的物理或虚拟机、云提供商或混合环境中运行。

Docker 的可移植性和轻量级特性还使得动态管理工作负载变得容易，可以根据业务需求近乎实时地扩展或缩减应用程序和服务。

**在同一硬件上运行更多工作负载**
Docker 是轻量级且快速的。它提供了一种可行的、具有成本效益的替代基于管理程序的虚拟机的方法，因此您可以利用更多的服务器容量来实现业务目标。Docker 非常适合高密度环境以及中小型部署，在这些场景中，您需要用更少的资源完成更多工作。

------

**Docker 架构**

Docker 使用**客户端-服务器架构**。Docker 客户端与 Docker 守护进程通信（即Docker daemon），后者负责构建、运行和分发 Docker 容器的繁重工作。**Docker 客户端和守护进程可以在同一系统上运行，也可以将 Docker 客户端连接到远程 Docker 守护进程。Docker 客户端和守护进程通过 REST API 进行通信，使用 UNIX 套接字或网络接口**。**另一个 Docker 客户端**是 **Docker Compose**，**它允许您处理由一组容器组成的应用程序**。



**Docker 架构图**

![Docker Architecture diagram](https://docs.docker.com/get-started/images/docker-architecture.webp)

**Docker 守护进程**
Docker 守护进程（dockerd）监听 Docker API 请求并管理 Docker 对象，例如镜像、容器、网络和卷。守护进程还可以与其他守护进程通信以管理 Docker 服务。

**Docker 客户端**
Docker 客户端（docker）是许多 Docker 用户与 Docker 交互的主要方式。当您使用诸如 `docker run` 之类的命令时，客户端会将这些命令发送给 dockerd 执行。`docker` 命令使用 Docker API。Docker 客户端可以与多个守护进程通信。

**Docker Desktop**
Docker Desktop 是一款适用于 Mac、Windows 或 Linux 环境的易于安装的应用程序，使您能够构建和共享容器化应用程序和微服务。Docker Desktop 包括 Docker 守护进程（dockerd）、Docker 客户端（docker）、Docker Compose、Docker Content Trust、Kubernetes 和 Credential Helper。有关更多信息，请参阅 Docker Desktop。

**Docker 注册表**
Docker 注册表存储 Docker 镜像。Docker Hub 是一个任何人都可以使用的公共注册表，默认情况下 Docker 会在 **Docker Hub** 上查找镜像。您甚至可以运行自己的私有注册表。

当您使用 `docker pull` 或 `docker run` 命令时，Docker 会从您配置的注册表中拉取所需的镜像。当您使用 `docker push` 命令时，Docker 会将您的镜像推送到您配置的注册表。

**Docker 对象**
当您使用 Docker 时，您会创建和使用镜像、容器、网络、卷、插件和其他对象。本节简要概述了其中一些对象。

**镜像**
镜像是一个只读模板，其中包含创建 Docker 容器的指令。通常，一个镜像是基于另一个镜像的，并带有一些额外的自定义。例如，您可以基于 ubuntu 镜像构建一个新镜像，但会安装 Apache Web 服务器和您的应用程序，以及使您的应用程序运行所需的配置细节。

您可以创建自己的镜像，也可以仅使用他人创建并发布在注册表中的镜像。要构建自己的镜像，您需要创建一个 Dockerfile，它使用简单的语法来定义创建和运行镜像所需的步骤。Dockerfile 中的每条指令都会在镜像中创建一个层。**当您更改 Dockerfile 并重新构建镜像时，只有那些已更改的层会被重建。这是使镜像相较于其他虚拟化技术如此轻量、小巧和快速的原因之一。**

**容器**
容器是镜像的可运行实例。您可以使用 Docker API 或 CLI 创建、启动、停止、移动或删除容器。您可以将容器连接到一个或多个网络，为其附加存储，甚至可以根据其当前状态创建新镜像。

默认情况下，容器与其他容器及其主机相对隔离。您可以控制容器的网络、存储或其他底层子系统与其他容器或主机的隔离程度。

容器由其镜像以及您在创建或启动时提供给它的任何配置选项定义。当容器被删除时，其状态中未存储在持久存储中的任何更改都会消失。

**网络**

容器默认有一个隔离的网络栈。你可以创建自定义的 Docker 网络，将多个容器加入同一个网络，它们之间可以通过容器名互相通信（比如应用容器用 `mysql` 这个主机名就能访问数据库容器），与外部隔离。

**卷**

容器的文件层是临时的，容器删除数据就没了。**卷**是 Docker 管理的、独立于容器生命周期的持久化数据存储。比如把数据库容器的数据目录挂载到一个卷上，这样即使删除并重建容器，数据也不会丢失。

**插件**

用于扩展 Docker 功能。例如，网络插件可以让 Docker 容器接入复杂的第三方网络方案（如 Weave Net）；存储插件可以让卷使用云存储（如 AWS EBS）。

**其他对象**还包括 **配置**（将配置文件注入容器）、**密钥**（安全地传递密码等敏感信息）等

**示例 docker run 命令**
以下命令运行一个 ubuntu 容器，以交互方式附加到本地命令行会话，并运行 `/bin/bash`：

```
docker run -i -t ubuntu /bin/bash
```



当您运行此命令时，会发生以下情况（假设您使用的是默认的注册表配置）：

1. 如果您本地没有 ubuntu 镜像，Docker 会从您配置的注册表中拉取它，就像您手动运行了 `docker pull ubuntu` 一样。
2. Docker 创建一个新容器，就像您手动运行了 `docker container create` 命令一样。
3. Docker 为容器分配一个读写文件系统，作为其最顶层。这使得正在运行的容器可以在其本地文件系统中创建或修改文件和目录。
4. 由于您未指定任何网络选项，Docker 会创建一个网络接口以将容器连接到默认网络。这包括为容器分配一个 IP 地址。默认情况下，容器可以使用主机的网络连接连接到外部网络。
5. Docker 启动容器并执行 `/bin/bash`。由于容器是以交互方式运行并附加到您的终端（由于 `-i` 和 `-t` 标志），您可以使用键盘输入，同时 Docker 将输出记录到您的终端。

当您运行 `exit` 终止 `/bin/bash` 命令时，容器会停止但不会被移除。您可以重新启动它或将其移除。

------

**底层技术**

Docker 是用 Go 编程语言编写的，并利用 Linux 内核的若干特性来提供其功能。Docker 使用一种称为命名空间（namespaces）的技术来提供称为容器的隔离工作空间。当您运行一个容器时，Docker 会为该容器创建一组命名空间。

这些命名空间提供了一层隔离。容器的每个方面都在一个单独的命名空间中运行，其访问权限仅限于该命名空间。

**解析：命名空间隔离详解**

这是 Docker 隔离性的核心。**命名空间不是“一个”东西，而是一组（多个）机制。**

**误解：** “命名空间是用来隔离容器的” → 这个说法不精确。
**正解：** **Docker 使用多类命名空间共同协作，从不同“方面”隔离容器，这些方面的总和构成了一个完整的容器。**

**“容器的每个方面”对应一类命名空间：**

1. **PID 命名空间：** 隔离进程ID。容器内的进程认为自己的 PID 是 1（init进程），看不到主机上的其他进程。
2. **Network 命名空间：** 隔离网络栈。容器有自己的网卡、IP 地址、路由表、端口空间。容器内查看到的 `localhost` (`127.0.0.1`) 是容器自己的，不是宿主机的。
3. **Mount 命名空间：** 隔离文件系统挂载点。容器可以看到自己的根文件系统 `/`，而不会看到宿主机的整个磁盘目录结构（除非你显式挂载）。
4. **UTS 命名空间：** 隔离主机名和域名。容器可以有自己的 `hostname`，独立于主机。
5. **IPC 命名空间：** 隔离进程间通信资源（如消息队列、共享内存）。
6. **User 命名空间：** 隔离用户和用户组ID。容器内的 `root` 用户可以被映射到主机上的一个非特权用户，增加安全性。

**所以，“容器的每个方面都在一个单独的命名空间中运行”** 意思是：容器的**进程**、**网络**、**文件系统**、**主机名**等各个方面，分别被对应类型的命名空间“包裹”起来，与主机和其他容器隔离开。**这不是在容器内部再进行隔离，而是用多个“隔离罩”从外部把容器的各个资源维度包裹起来，从而塑造出这个独立的容器环境。**

总结来说，Docker 通过这种精细的、多维度命名空间隔离，加上 **Control Groups（cgroups）** 来限制资源使用（CPU、内存），实现了轻量级、安全且高性能的虚拟化效果。