### **第3部分：Linux命令行操作**

这是Linux系统的灵魂。与图形界面相比，命令行（CLI）更高效、更强大、更灵活，尤其对于服务器管理和自动化任务。

#### **3.1 Shell概述**

- **是什么**：Shell是用户与Linux内核之间的“翻译官”和“中间人”。它是一个命令行解释器，你输入文本命令，它理解后调用内核和程序来执行，并把结果返回给你。
- **作用**：提供用户接口、执行命令、运行脚本、管理作业、提供编程环境。
- **常见Shell**：
  - **Bash (Bourne-Again SHell)**：Linux系统默认、最流行的Shell。功能强大，兼容性好。我们学习将以Bash为主。
  - **Zsh**：功能更丰富，社区活跃，配合Oh-My-Zsh框架后非常强大，是许多高级用户和开发者的选择。
  - **其他**：sh（最原始）、csh、tcsh等。

#### **3.2 常用命令 (你必须掌握的生存工具)**

这不仅仅是记住命令，更要理解其思维模式。Linux命令遵循 `命令 [选项] [参数]` 的通用格式。

1. **导航与查看**：

   - `pwd`：**打印工作目录**。告诉你“我现在在哪里”（当前目录的绝对路径）。
   - `cd [目录路径]`：**改变目录**。如 `cd /home`，`cd ..`（上级目录），`cd ~` 或 `cd`（家目录），`cd -`（返回上一个目录）。
   - `ls`：**列出目录内容**。
     - `ls -l`：以长格式（详细信息）列出。
     - `ls -a`：列出所有文件（包括以`.`开头的隐藏文件）。
     - `ls -lh`：以人类可读方式（K, M, G）显示文件大小。

2. **文件操作**：

   - `cat`：**连接并显示文件内容**。适合查看短文件。`cat file.txt`。`cat` 命令的全称是 **concatenate**，意为“连接、串联”。它的**原始核心功能**是将多个文件的内容连接（合并）在一起，然后输出到标准输出（通常是屏幕）。

     ```bash
     # 将 file1.txt 和 file2.txt 的内容连接起来，并显示在屏幕上
     cat file1.txt file2.txt
     ```

   - **echo**：打印文本；用法：`echo "text"`

   - `less` / `more`：**分页查看文件内容**。适合长文件。`less file.log`，用空格翻页，`q`退出。**`less`比`more`功能更强，推荐使用。**

   - `head` / `tail`：查看文件**头**或**尾**的N行。`tail -20 file.log`（看最后20行），`tail -f file.log`（**实时追踪**文件尾部新增内容，对看日志至关重要！）。

   - `cp`：**复制文件或目录**。`cp source dest`，`cp -r dir1 dir2`（递归复制目录）。

   - `mv`：**移动或重命名**。`mv oldname newname`，`mv file /path/to/`。

   - `rm`：**删除**。**危险命令！Linux没有回收站！**

     - `rm file`，`rm -r dir`（递归删除目录），`rm -f file`（强制删除）。
     - **专家建议**：先 `ls` 确认文件，再执行 `rm`。对重要目录，可先 `mv` 到一个临时备份位置。

   - `mkdir` / `rmdir`：**创建目录** / **删除空目录**。

   - `touch`：创建空文件，或更新已有文件的访问/修改时间戳。

3. **信息查找与过滤**：

   - `grep`：**文本搜索神器**。在文件或输入流中查找包含特定模式的行。
     - `grep "error" file.log`（查找包含“error”的行）。
     - `grep -r "function" /path/to/code/`（递归搜索目录中所有文件）。
     - `grep -i "warning"`（忽略大小写）。
     - `grep -v "success"`（**反选**，输出不包含“success”的行）。
   - `find`：**文件查找神器**。在目录树中根据名称、类型、大小、时间等查找文件。
     - `find /home -name "*.txt"`（在家目录下找所有.txt文件）。
     - `find /var/log -type f -mtime -7`（在/var/log下找7天内修改过的普通文件）。
     - `find . -size +10M`（在当前目录找大于10M的文件）。
   - `which` / `whereis`：**查找命令位置**。`which python` 告诉你执行的是哪个`python`程序。`whereis ls` 显示命令的二进制文件、源代码和手册页位置。

4. **系统状态**：

   - `ps`：**查看进程快照**。`ps aux` 查看系统所有进程的详细信息。
   - `top` / `htop`：**动态、交互式查看进程和系统资源**（CPU、内存）。`htop`是`top`的增强版，更直观。
   - `df`：**查看磁盘空间使用情况**。`df -h`（人类可读格式）。
   - `du`：**查看目录/文件的磁盘使用量**。`du -sh /home/*`（查看/home下各目录总大小）。

#### **3.3 管道与重定向 (组合命令，威力无穷)**

这是Linux哲学“一个程序只做好一件事，通过管道组合小工具完成复杂任务”的核心体现。它们允许你将一个命令的输出作为另一个命令的输入，从而可以构建更复杂的数据处理链条。

- **管道 `|`**：将一个命令的**标准输出**作为下一个命令的**标准输入**。
  - 例子：`ps aux | grep nginx`（先列出所有进程，然后在结果中搜索“nginx”）。
  - 例子：`cat access.log | cut -d' ' -f1 | sort | uniq -c | sort -nr`（分析日志，提取IP，排序去重计数，再按访问量降序排列——一行命令完成复杂分析）。
- **重定向**：
  - `>`：将命令输出**覆盖**写入到文件。`echo "Hello" > file.txt`（file.txt内容变为Hello）。
  - `>>`：将命令输出**追加**到文件末尾。`echo "World" >> file.txt`（file.txt内容变成 Hello\nWorld）。
  - `<`：将文件内容作为命令的输入。`sort < unsorted_list.txt`。
  - `2>`：重定向**标准错误输出**。`command 2> error.log`。
  - `&>`：重定向**标准输出和标准错误**。`command &> all_output.log`。

#### **3.4 文本处理工具 (数据处理三剑客)**

处理结构化/非结构化文本是系统管理的日常。

1. **`awk`**：一种强大的文本分析编程语言。擅长处理**按列（字段）分隔**的文本（如CSV、日志）。
   - 基本模式：`awk 'pattern {action}' file`
   - 例子：`awk -F':' '{print $1, $7}' /etc/passwd`（以`:`分隔，打印第1列（用户名）和第7列（默认shell））。
   - 例子：`awk '$3 > 1000 {print $0}' data.txt`（打印第三列大于1000的所有行）。
2. **`sed`**：**流编辑器**。擅长对文本进行**查找、替换、删除、插入**等操作。
   - 基本模式：`sed 's/查找内容/替换内容/[标志]' file`。`s`表示替换。
   - 例子：`sed 's/foo/bar/g' file.txt`（将文件中所有的`foo`替换为`bar`，`g`表示全局）。
   - 例子：`sed -i.bak 's/old/new/' config.conf`（**原地编辑**文件，并创建`.bak`备份。**使用`-i`要非常小心！**）。
3. **`cut`**：**按列切割文本**。简单直接。
   - 例子：`cut -d',' -f1,3 data.csv`（用逗号分隔，取第1和第3列）。
4. **`sort`**：**排序**。
   - 例子：`sort file.txt`，`sort -nr file.txt`（按数字逆序排序）。
5. **`uniq`**：**去重**。通常与`sort`联用，因为`uniq`只能去除**相邻的**重复行。
   - 例子：`sort file.txt | uniq -c`（排序后去重并计数）。